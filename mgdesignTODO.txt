=== Done

L.Matrix23
L.Map ; ajouté un _transform

L.Map.getPixelBounds ; voir si nécessaire de changer
* représente apparemment les bounds en pixel dans l'espace de tuiles global
* la transformation doit probablement se faire dans cet espace
* applique le _transform inverse autour du centre de la map (en pixels)

L.GridLayer._initContainer
* applique une transformation CSS (celle de la map)
* centrée sur le milieu de la map

appliquer le _tranform de la map aux positions de pictos
* Map.latLngToLayerPoint

* ajout Map._initialCenterPoint & Map._getPixelCenter

=== TODO

bug sélection tuiles à charger et zoom avec rotation à 45/90°
* Map._getTopLeftPoint utilise Map.getPixelOrigin & Map._getMapPanePos (delta dû au drag)
* le delta du drag devrait prendre en compte la transformation
* => supprimer _getTopLeftPoint
* ne peut pas supprimer getPixelOrigin (qui ne fait que retourner _initialTopLeftPoint)
* on dirait qu'il reste un problème d'inversion des directions quand rotations ; les tuiles se chargent à l'opposé en x/y par rapport au drag...
* ok c'était les matrices qui étaient fausses

gérer le zoom animé
L.Bounds ; ajouter une méthode pour obtenir les 4 coins
L.Map.getPixelOrigin ; voir si à transformer, attention aux récursions infinies, utilisé par '_getTopLeftPoint'

=== Ecarté

L.Bounds ; ajouter un constructeur à 4 points (min max fait dans la fonction) => OK, prend déjà un tableau
L.Transformation ; ajouter des coefs pour avoir une vraie matrice
* trop de regressions possibles ; plutot nouvelle classe Matrix23
L.Map.getBounds ; transformer les quatre coins du pixel bounds puis calculer un nouveau bounds ; non plutot dans getPixelBounds

pour prototyper ; où mettre la matrice de transformation initiale ?
* si non spécifié :: L.CRS.EPSG3857
* bof non pas dans le CRS..
