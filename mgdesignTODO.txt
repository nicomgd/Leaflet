=== Done

L.Matrix23
L.Map ; ajouté un _transform

L.Map.getPixelBounds ; voir si nécessaire de changer
* représente apparemment les bounds en pixel dans l'espace de tuiles global
* la transformation doit probablement se faire dans cet espace
* applique le _transform inverse autour du centre de la map (en pixels)

L.GridLayer._initContainer
* applique une transformation CSS (celle de la map)
* centrée sur le milieu de la map

appliquer le _tranform de la map aux positions de pictos
* Map.latLngToLayerPoint

=== TODO

bug sélection tuiles à charger et zoom avec rotation à 90° ; même avec un scale à 0.5 quand on panne un peu..
* Map._getTopLeftPoint utilise Map.getPixelOrigin & Map._getMapPanePos (delta dû au drag)
* le delta du drag devrait prendre en compte la transformation
* => supprimer _getTopLeftPoint
* ne peut pas supprimer getPixelOrigin (qui ne fait que retourner _initialTopLeftPoint)
gérer le zoom animé
L.Bounds ; ajouter une méthode pour obtenir les 4 coins
L.Map.getPixelOrigin ; voir si à transformer, attention aux récursions infinies, utilisé par '_getTopLeftPoint'

=== Ecarté

L.Bounds ; ajouter un constructeur à 4 points (min max fait dans la fonction) => OK, prend déjà un tableau
L.Transformation ; ajouter des coefs pour avoir une vraie matrice
* trop de regressions possibles ; plutot nouvelle classe Matrix23
L.Map.getBounds ; transformer les quatre coins du pixel bounds puis calculer un nouveau bounds ; non plutot dans getPixelBounds

pour prototyper ; où mettre la matrice de transformation initiale ?
* si non spécifié :: L.CRS.EPSG3857
* bof non pas dans le CRS..
