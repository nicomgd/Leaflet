=== Coordinate systems

Container => Layer            => Projected/Pixel     => LatLng
(pixels)     (pixels, panned)    (pixels, tiles)     (crs)

=== Done

L.Matrix23
L.Map ; ajouté un _transform

L.Map.getPixelBounds ; voir si nécessaire de changer
* représente apparemment les bounds en pixel dans l'espace de tuiles global
* la transformation doit probablement se faire dans cet espace
* applique le _transform inverse autour du centre de la map (en pixels)

L.GridLayer._initContainer
* applique une transformation CSS (celle de la map)
* centrée sur le milieu de la map

appliquer le _tranform de la map aux positions de pictos
* Map.latLngToLayerPoint

* ajout Map._initialCenterPoint & Map._getPixelCenter
** pour appliquer la tranformation au drag

=== TODO

bug zoom out/in modifie le centre courant de la map (après drag)
* Map._resetView ? plutot non
* Map.setView ?
* Map.getCenter ?
* Map.layerPointToLatLng ? ou __Map.containerPointToLayerPoint__ ?
** en fait probablement toutes les fonctions appelant _getMapPanePos

gérer le zoom animé
L.Bounds ; ajouter une méthode pour obtenir les 4 coins
L.Map.getPixelOrigin ; voir si à transformer, attention aux récursions infinies, utilisé par '_getTopLeftPoint'

=== Ecarté

L.Bounds ; ajouter un constructeur à 4 points (min max fait dans la fonction) => OK, prend déjà un tableau
L.Transformation ; ajouter des coefs pour avoir une vraie matrice
* trop de regressions possibles ; plutot nouvelle classe Matrix23
L.Map.getBounds ; transformer les quatre coins du pixel bounds puis calculer un nouveau bounds ; non plutot dans getPixelBounds

pour prototyper ; où mettre la matrice de transformation initiale ?
* si non spécifié :: L.CRS.EPSG3857
* bof non pas dans le CRS..
